[


 ;; DB functions

 {:db/id #db/id[:db.part/user]
  :db/ident :append-position-in-scope
  :db/doc "Atomically adds to the end of a list of sorted cardinality/many lists"
  :db/fn #db/fn {:lang "clojure"
                 :params [db scope-id scope-attr new-id pos-attr]
                 :code [[:db/add new-id pos-attr
                         (as-> 
                             ;; The full set of children
                             (get (datomic.api/entity db scope-id) scope-attr) x
                           ;; Get only the numerical position attr
                           (map pos-attr x)
                           ;; Get the highest one
                           (reduce max 0 x)
                           ;; And increment by one
                           (inc x))]]}}
 
 
 {:db/id #db/id[:db.part/user]
  :db/ident :reset-position-in-scope
  :db/doc "Goes through existing positions and sequentializes them, assuming retracted-eid is being retracted from the list"
  :db/fn #db/fn {:lang "clojure"
                 :params [db scope-id scope-attr retracted-eid sorted-attr]
                 :code (map-indexed
                        (fn [idx entity-id]
                          [:db/add entity-id sorted-attr idx])
                        (as-> ;; The full set of children
                            (get (datomic.api/entity db scope-id)
                                 scope-attr) x
                          ;; Sort them by the numerical sorted-attr
                          (sort-by sorted-attr x)
                          ;; Get the entity IDs
                          (map :db/id x)
                          ;; Remove the retracted entity from the list
                          (filter (partial not= retracted-eid)) x))}}
 
 {:db/id #db/id[:db.part/user]
  :db/ident :set-position-in-scope
  :db/doc "Reposition consistently"
  :db/fn #db/fn {:lang "clojure"
                 :params [db scope-id scope-attr sorted-eids sorted-attr]
                 :code (map-indexed
                        (fn [idx entity-id]
                          [:db/add entity-id sorted-attr idx])
                        (concat
                         sorted-eids
                         (clojure.set/difference
                          (map :db/id (scope-attr (datomic.api/entity db scope-id)))
                          sorted-eids)))}}

 {:db/id #db/id[:db.part/user]
  :db/ident :reset-to-many
  :db/fn #db/fn {:lang :clojure
                 :requires [[datomic.api :as d]]
                 :params [db e attr new-vals]
                 :code (let [ent (or (d/entity db e)
                                     (throw (ex-info "Entity not found" 
                                                     {:e e :t (d/basis-t db)})))
                             entid (:db/id ent)
                             old-vals (get ent attr)]
                         (into
                          [{:db/id (:db/id ent)
                            ;; adding the new values
                            attr new-vals}]
                          ;; retracting the old values
                          (comp
                           (remove (set new-vals))
                           (map (fn [v]
                                  [:db/retract entid attr v])))
                          old-vals)
                         )}}
 
 {:db/id #db/id[:db.part/user]
  :db/ident :add-node
  :db/doc "Adds a childnode named 'basename' of nodetype 'primary-node-type' to the :jcr.node with entity-id 'parent-node-id'"
  :db/fn #db/fn {:lang "clojure"
                 :params [db node-id child-id rel-path primary-node-type]
                 :requires [[ccr.core.model-trans :as mt]
                            [ccr.core.path :as p]
                            [ccr.core.transaction-utils :as tu]
                            [ccr.core.transactor-support :as ts]]
                 :code (let [segments (p/to-path rel-path)
                             parent-segments (drop-last segments)
                             basename (last segments)
                             parent-node-id (ts/node-by-path db node-id parent-segments)
                             pnt (ts/primary-type db parent-node-id)
                             cnd-ids (ts/child-node-definition-ids db pnt)
                             matching-cnd-id (ts/matching-cnd-id db cnd-ids basename primary-node-type)
                             new-primary-node-type (if (not (nil? primary-node-type))
                                                     primary-node-type
                                                     (ts/default-primary-type db matching-cnd-id))
                             autocreated-childnodes (ts/autocreated-childnodes db matching-cnd-id)
                             autocreated-properties (ts/autocreated-properties db new-primary-node-type)]
                         #_(println autocreated-properties)
                         (if (nil? new-primary-node-type) (throw (IllegalArgumentException. "no primary nodetype specified")))
                         (as-> (mt/node-transaction basename autocreated-childnodes
                                                    autocreated-properties) x
                           (tu/translate-value2 x child-id)
                           (let [child-node-tx (second x)
                                 tx (concat (tu/add-tx parent-node-id child-id) child-node-tx)]
                             #_(println "tx" tx)
                             tx
                             )))}}

{:db/id #db/id[:db.part/user]
  :db/ident :set-property
  :db/doc "Sets the property of the node (with node-id) called name to the specified values. Even if this property is single-valued the parameter values has to be a coll"
  :db/fn #db/fn {:lang "clojure"
                 :params [db node-id property-id name values jcr-type multiple?]
                 :requires [[ccr.core.model-trans :as mt]
                            [ccr.core.path :as p]
                            [ccr.core.cnd :as cnd]
                            [ccr.core.transaction-utils :as tu]
                            [ccr.core.transactor-support :as ts]]
                 :code (do (when (nil? node-id) (throw (IllegalArgumentException. "Parameter 'node-id' must not be null")))
                           (when (nil? name) (throw (IllegalArgumentException. "Parameter 'name' must not be null")))
                           (when (nil? jcr-type) (throw (IllegalArgumentException. "Parameter 'jcr-type' must not be null")))
                           (when (not (coll? values)) (throw (IllegalArgumentException. "Parameter 'values' must be a collection")))
                           (let [pt (ts/primary-type db node-id)
                                 propdef-ids (ts/property-definition-ids db pt)
                                 matching-propdef-id (ts/matching-propdef-id db propdef-ids name multiple? jcr-type)
                                 value-attr (cnd/jcr-value-attr jcr-type)
                                 prop-id (ts/property-by-name db node-id name)]
                             (if (nil? prop-id)

                               ;; new property
                               (as-> (mt/property-transaction name value-attr values) x
                                 (tu/translate-value2 x property-id)
                                 (let [;;property-id (first x)
                                       property-tx (second x)
                                       tx (concat (tu/add-prop-tx node-id property-id) property-tx)]
                                   #_(println "tx" tx)
                                   tx))

                               ;; existing property
                               (let [old-values-entities (ts/value-entities db prop-id)
                                     {:keys [retractions additions]} (mt/update-values prop-id old-values-entities values value-attr)]
                                     (as-> additions x
                                         (tu/translate-value2 x nil)
                                       (let [value-ids (first x)
                                             property-tx (second x)
                                             tx (concat retractions (tu/add-vals-tx prop-id value-ids) property-tx)]
                                         #_(println "tx" tx)
                                         tx))))))
                 }
 }
 ]
