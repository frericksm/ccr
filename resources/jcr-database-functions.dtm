[


 ;; DB functions

 {:db/id #db/id[:db.part/user]
  :db/ident :append-position-in-scope
  :db/doc "Atomically adds to the end of a list of sorted cardinality/many lists"
  :db/fn #db/fn {:lang "clojure"
                 :params [db scope-id scope-attr new-id pos-attr]
                 :code [[:db/add new-id pos-attr
                         (as-> 
                             ;; The full set of children
                             (get (datomic.api/entity db scope-id) scope-attr) x
                           ;; Get only the numerical position attr
                           (map pos-attr x)
                           ;; Get the highest one
                           (reduce max 0 x)
                           ;; And increment by one
                           (inc x))]]}}
 
 
 {:db/id #db/id[:db.part/user]
  :db/ident :reset-position-in-scope
  :db/doc "Goes through existing positions and sequentializes them, assuming retracted-eid is being retracted from the list"
  :db/fn #db/fn {:lang "clojure"
                 :params [db scope-id scope-attr retracted-eid sorted-attr]
                 :code (map-indexed
                        (fn [idx entity-id]
                          [:db/add entity-id sorted-attr idx])
                        (as-> ;; The full set of children
                            (get (datomic.api/entity db scope-id)
                                 scope-attr) x
                          ;; Sort them by the numerical sorted-attr
                          (sort-by sorted-attr x)
                          ;; Get the entity IDs
                          (map :db/id x)
                          ;; Remove the retracted entity from the list
                          (filter (partial not= retracted-eid)) x))}}
 
 {:db/id #db/id[:db.part/user]
  :db/ident :set-position-in-scope
  :db/doc "Reposition consistently"
  :db/fn #db/fn {:lang "clojure"
                 :params [db scope-id scope-attr sorted-eids sorted-attr]
                 :code (map-indexed
                        (fn [idx entity-id]
                          [:db/add entity-id sorted-attr idx])
                        (concat
                         sorted-eids
                         (clojure.set/difference
                          (map :db/id (scope-attr (datomic.api/entity db scope-id)))
                          sorted-eids)))}}

 {:db/id #db/id[:db.part/user]
  :db/ident :add-node
  :db/doc "Adds a childnode named 'basename' of nodetype 'primary-node-type' to the :jcr.node with entity-id 'parent-node-id'"
  :db/fn #db/fn {:lang "clojure"
                 :params [db node-id rel-path primary-node-type]
                 :requires [[ccr.core.model-trans :as mt]
                            [ccr.core.path :as p]
                            [ccr.core.transaction-utils :as tu]
                            [ccr.core.transactor-support :as ts]]
                 :code (let [segments (p/to-path rel-path)
                             parent-segments (drop-last segments)
                             basename (last segments)
                             parent-node-id (ts/node-by-path db node-id parent-segments)
                             pnt (ts/primary-type db parent-node-id)
                             cnd-ids (ts/child-node-definition-ids db pnt)
                             matching-cnd-id (ts/matching-cnd-id db cnd-ids basename primary-node-type)
                             new-primary-node-type (if (not (nil? primary-node-type))
                                                     primary-node-type
                                                     (ts/default-primary-type db matching-cnd-id))
                             autocreated-childnodes (ts/autocreated-childnodes db matching-cnd-id)
                             autocreated-properties (ts/autocreated-properties db new-primary-node-type)]
                         #_(println autocreated-properties)
                         (if (nil? new-primary-node-type) (throw (IllegalArgumentException. "no primary nodetype specified")))
                         (as-> (mt/node-transaction basename autocreated-childnodes
                                                    autocreated-properties) x
                           (tu/translate-value x)
                           (let [child-id (first x)
                                 child-node-tx (second x)
                                 tx (concat (tu/add-tx parent-node-id child-id) child-node-tx)]
                             #_(println "tx" tx)
                             tx
                             )))}}

{:db/id #db/id[:db.part/user]
  :db/ident :set-property
  :db/doc "Sets the property of the node (with node-id) called name to the specified values. Even if this property is single-valued the value has to put into a seq values"
  :db/fn #db/fn {:lang "clojure"
                 :params [db node-id name values]
                 :requires [[ccr.core.model-trans :as mt]
                            [ccr.core.path :as p]
                            [ccr.core.transaction-utils :as tu]
                            [ccr.core.transactor-support :as ts]]
                 :code (let [pnt (ts/primary-type db parent-node-id)
                             cnd-ids (ts/child-node-definition-ids db pnt)
                             matching-cnd-id (ts/matching-cnd-id db cnd-ids basename primary-node-type)
                             new-primary-node-type (if (not (nil? primary-node-type))
                                                     primary-node-type
                                                     (ts/default-primary-type db matching-cnd-id))
                             autocreated-childnodes (ts/autocreated-childnodes db matching-cnd-id)
                             autocreated-properties (ts/autocreated-properties db new-primary-node-type)]
                         #_(println autocreated-properties)
                         (if (nil? new-primary-node-type) (throw (IllegalArgumentException. "no primary nodetype specified")))
                         (as-> (mt/node-transaction basename autocreated-childnodes
                                                    autocreated-properties) x
                           (tu/translate-value x)
                           (let [child-id (first x)
                                 child-node-tx (second x)
                                 tx (concat (tu/add-tx parent-node-id child-id) child-node-tx)]
                             #_(println "tx" tx)
                             tx
                             )))}}
]
