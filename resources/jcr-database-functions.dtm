[ ;; DB functions

 {:db/id #db/id[:db.part/user]
  :db/ident :append-position-in-scope
  :db/doc "Atomically adds to the end of a list of sorted cardinality/many lists"
  :db/fn #db/fn {:lang "clojure"
                 :params [db scope-id scope-attr new-id pos-attr]
                 :code [[:db/add new-id pos-attr
                         (as-> 
                             ;; The full set of children
                             (get (datomic.api/entity db scope-id) scope-attr) x
                           ;; Get only the numerical position attr
                             (map pos-attr x)
                             ;; Get the highest one
                             (reduce max 0 x)
                             ;; And increment by one
                             (inc x))]]}}
 
 
 {:db/id #db/id[:db.part/user]
  :db/ident :reset-position-in-scope
  :db/doc "Goes through existing positions and sequentializes them, assuming retracted-eid is being retracted from the list"
  :db/fn #db/fn {:lang "clojure"
                 :params [db scope-id scope-attr retracted-eid sorted-attr]
                 :code (map-indexed
                        (fn [idx entity-id]
                          [:db/add entity-id sorted-attr idx])
                        (as-> ;; The full set of children
                            (get (datomic.api/entity db scope-id)
                                 scope-attr) x
                          ;; Sort them by the numerical sorted-attr
                            (sort-by sorted-attr x)
                            ;; Get the entity IDs
                            (map :db/id x)
                            ;; Remove the retracted entity from the list
                            (filter (partial not= retracted-eid)) x))}}
 
 {:db/id #db/id[:db.part/user]
  :db/ident :set-position-in-scope
  :db/doc "Reposition consistently"
  :db/fn #db/fn {:lang "clojure"
                 :params [db scope-id scope-attr sorted-eids sorted-attr]
                 :code (map-indexed
                        (fn [idx entity-id]
                          [:db/add entity-id sorted-attr idx])
                        (concat
                         sorted-eids
                         (clojure.set/difference
                          (map :db/id (scope-attr (datomic.api/entity db scope-id)))
                          sorted-eids)))}}

 {:db/id #db/id[:db.part/user]
  :db/ident :reset-to-many
  :db/fn #db/fn {:lang :clojure
                 :requires [[datomic.api :as d]]
                 :params [db e attr new-vals]
                 :code (let [ent (or (d/entity db e)
                                     (throw (ex-info "Entity not found" 
                                                     {:e e :t (d/basis-t db)})))
                             entid (:db/id ent)
                             old-vals (get ent attr)]
                         (into
                          [{:db/id (:db/id ent)
                            ;; adding the new values
                            attr new-vals}]
                          ;; retracting the old values
                          (comp
                           (remove (set new-vals))
                           (map (fn [v]
                                  [:db/retract entid attr v])))
                          old-vals)
                         )}}
 
 {:db/id #db/id[:db.part/user]
  :db/ident :add-node
  :db/doc "Adds a childnode named 'basename' of nodetype 'primary-node-type' to the :jcr.node with entity-id 'parent-node-id'"
  :db/fn #db/fn {:lang "clojure"
                 :params [db node-id child-id rel-path primary-node-type]
                 :requires [[ccr.core.database-functions :as database-functions]]
                 :code (database-functions/add-node db node-id child-id rel-path primary-node-type)}}

 {:db/id #db/id[:db.part/user]
  :db/ident :set-property
  :db/doc "Sets the property of the node (with node-id) called name to the specified values. Even if this property is single-valued the parameter values has to be a coll"
  :db/fn #db/fn {:lang "clojure"
                 :params [db node-id property-id name values jcr-type multiple?]
                 :requires [[ccr.core.database-functions :as database-functions]]
                 :code 
                 (database-functions/set-property db node-id property-id name values jcr-type multiple? )}}


 {:db/id #db/id[:db.part/user]
  :db/ident :save
  :db/doc "Save changes made in a session to the database by providing the transaction to be transacted against the connection"
  :db/fn #db/fn {:lang "clojure"
                 :params [db transactions]
                 :requires [[ccr.core.database-functions :as database-functions]]
                 :code (database-functions/save db transactions)}}

 ]
